<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Santiago Rodriguez">
<meta name="dcterms.date" content="2024-09-30">

<title>Algorithms â€“ Data Structures and Algorithms</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Data Structures and Algorithms</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/santiagorodriguez91/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/SaintRod/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://gitlab.com/hail_hydra"> <i class="bi bi-gitlab" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../posts/algorithms/post.html">Algorithms</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../posts/course/post.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">The Course</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../posts/algorithms/post.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../posts/data-structures/post.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data Structures</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#algorithms" id="toc-algorithms" class="nav-link active" data-scroll-target="#algorithms">Algorithms</a></li>
  <li><a href="#algorithmic-thinking" id="toc-algorithmic-thinking" class="nav-link" data-scroll-target="#algorithmic-thinking">Algorithmic thinking</a></li>
  <li><a href="#what-is-a-good-algorithm" id="toc-what-is-a-good-algorithm" class="nav-link" data-scroll-target="#what-is-a-good-algorithm">What is a good algorithm</a>
  <ul class="collapse">
  <li><a href="#correctness" id="toc-correctness" class="nav-link" data-scroll-target="#correctness">Correctness</a></li>
  <li><a href="#efficiency" id="toc-efficiency" class="nav-link" data-scroll-target="#efficiency">Efficiency</a></li>
  </ul></li>
  <li><a href="#big-o" id="toc-big-o" class="nav-link" data-scroll-target="#big-o">Big O</a>
  <ul class="collapse">
  <li><a href="#common-complexities" id="toc-common-complexities" class="nav-link" data-scroll-target="#common-complexities">Common complexities</a>
  <ul class="collapse">
  <li><a href="#constant-time" id="toc-constant-time" class="nav-link" data-scroll-target="#constant-time">Constant time</a></li>
  <li><a href="#polynomial-runtime" id="toc-polynomial-runtime" class="nav-link" data-scroll-target="#polynomial-runtime">Polynomial runtime</a></li>
  <li><a href="#exponential-runtime" id="toc-exponential-runtime" class="nav-link" data-scroll-target="#exponential-runtime">Exponential runtime</a></li>
  <li><a href="#factorial-or-combinatorial-runtimes" id="toc-factorial-or-combinatorial-runtimes" class="nav-link" data-scroll-target="#factorial-or-combinatorial-runtimes">Factorial or combinatorial runtimes</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#calculating-worst-case-complexity" id="toc-calculating-worst-case-complexity" class="nav-link" data-scroll-target="#calculating-worst-case-complexity">Calculating [worst case] complexity</a></li>
  <li><a href="#recursion-and-space-complexity" id="toc-recursion-and-space-complexity" class="nav-link" data-scroll-target="#recursion-and-space-complexity">Recursion and space complexity</a>
  <ul class="collapse">
  <li><a href="#binary-search-1" id="toc-binary-search-1" class="nav-link" data-scroll-target="#binary-search-1">Binary search</a></li>
  </ul></li>
  <li><a href="#search-algos" id="toc-search-algos" class="nav-link" data-scroll-target="#search-algos">Search algos</a></li>
  <li><a href="#sorting-algos" id="toc-sorting-algos" class="nav-link" data-scroll-target="#sorting-algos">Sorting algos</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Algorithms</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Santiago Rodriguez </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">September 30, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>The algorithms portion of the video lasts until 1:57:00 mark.</p>
<section id="algorithms" class="level1">
<h1>Algorithms</h1>
<p>Overview:</p>
<ul>
<li>An algorithm must have:
<ul>
<li>A clear problem statement</li>
<li>Input</li>
<li>Output</li>
</ul></li>
</ul>
<p>Def: Algorithm</p>
<ul>
<li>A set of steps or instructions to complete a task</li>
<li>A set of steps a program takes to finish a task</li>
</ul>
<p>Guidelines:</p>
<ul>
<li>Must have a <strong>specific</strong> set of instructions in a <strong>particular</strong> order
<ul>
<li>The steps of the algo must be in a specific order</li>
</ul></li>
<li>Each step must be <strong>simple</strong> and <strong>explicitly</strong> clear
<ul>
<li>Each step cannot be broken into simpler sub-tasks</li>
</ul></li>
<li>Should produce a result (output)
<ul>
<li>The algo must produce consistent results for the same set of values</li>
</ul></li>
<li>Should actually complete and not run forever</li>
</ul>
<p>Guidelines (stated differently):</p>
<ul>
<li>The steps of the algo must be in a [very] specific order</li>
<li>The steps need to be distinct</li>
<li>Should produce a result (output)</li>
<li>The algo should complete in a finite amount of time</li>
</ul>
<div style="page-break-after: always;"></div>
</section>
<section id="algorithmic-thinking" class="level1">
<h1>Algorithmic thinking</h1>
<p>Def: breaking a problem down into distinct steps</p>
<ul>
<li>Establish the bounds of the problem
<ul>
<li>clearly define what the problem set is</li>
<li>clarify what values count as inputs</li>
</ul></li>
</ul>
<div style="page-break-after: always;"></div>
</section>
<section id="what-is-a-good-algorithm" class="level1">
<h1>What is a good algorithm</h1>
<p>A clearly defined problem statement is essential to evaluate the algorithm.</p>
<p>Strategies to measure how <em>good</em> an algorithm is:</p>
<ol type="1">
<li>Best case</li>
<li>Average case</li>
<li>Worst case (recommended)</li>
</ol>
<p>Measured by worst case because an algorithm can never perform worse than the worst case scenario.</p>
<section id="correctness" class="level2">
<h2 class="anchored" data-anchor-id="correctness">Correctness</h2>
<p>Def: An algorithm is deemed correct if on every run of the algorithm against all possible inputs, the result is expected output</p>
<p>The definition implies that correctness can be tested (i.e., unit tests). More broadly, this notion of expected results provides a useful framework to test any procedure (e.g., data prep steps in an analytic project).</p>
<p>Advanced topic: proof through induction</p>
</section>
<section id="efficiency" class="level2">
<h2 class="anchored" data-anchor-id="efficiency">Efficiency</h2>
<p>Def: Time complexity - a measure of how long it takes the algorithm to run Def: Space complexity - the amount of memory taken up on the computer Def: run - executing the algorithm with a particular input Def: Order of growth</p>
<ul>
<li>AKA the growth rate of an algorithm</li>
<li>A measure of how the algorithm performs as the input length/size grows</li>
<li>The standard way to evaluate an algorithm</li>
</ul>
<p>Measures of efficiency:</p>
<ul>
<li>Time</li>
<li>Space</li>
</ul>
<p><em>Good</em> algorithms balance time and space efficiency.</p>
<p>Since computers can handle large computations, efficiency is measured with very large input lengths (denoted by <span class="math inline">\(n\)</span>)</p>
<p>To compare algorithms, it can be useful to plot the results of many runs.</p>
<p>If plotting the results:</p>
<ul>
<li>y axis: tries or time</li>
<li>x axis: n (input length)</li>
</ul>
<p>The plot helps us see the <em>growth rate</em> or the <em>order of growth</em> of the algorithm(s).</p>
<div style="page-break-after: always;"></div>
</section>
</section>
<section id="big-o" class="level1">
<h1>Big O</h1>
<p>Def: Big O</p>
<ul>
<li>Theoretical definition of the complexity of an algorithm as a function of the size [of the input]</li>
<li>A notation used to define complexity</li>
<li>Denoted as <span class="math inline">\(O()\)</span>, where <span class="math inline">\(O\)</span> stands for <em>Order of magnitude of complexity</em></li>
<li>Also refered to as the upper bound or upper limit of the algorithm</li>
</ul>
<p>Big O is a tool used to compare complexity of different algorithms that solve the same problem. For example, Big O can be used to compare linear search and binay tree because both are search algorithms. But not linear search to a sorting algorithm.</p>
<p>Examples:</p>
<ul>
<li>Linear search has a time complexity of <span class="math inline">\(O(n)\)</span></li>
<li>Binary search has a time complexity of <span class="math inline">\(O(log(n))\)</span></li>
</ul>
<section id="common-complexities" class="level2">
<h2 class="anchored" data-anchor-id="common-complexities">Common complexities</h2>
<p>Common values of Big o <span class="math inline">\(O()\)</span> or time complexities of known algorithms that should be memorized.</p>
<p>Presented in order of best to worst or most efficient to least efficient.</p>
<section id="constant-time" class="level3">
<h3 class="anchored" data-anchor-id="constant-time">Constant time</h3>
<ul>
<li>Denoted as <span class="math inline">\(O(1)\)</span></li>
<li>Takes the same time regardless of the size of n</li>
</ul>
<p>An example of constant time is reading a value in a list. How long it takes to read the value doesnâ€™t change <em>as a function of n</em>.</p>
<p>Constant time is <strong>ideal</strong> because input size doesnâ€™t matter.</p>
</section>
<section id="polynomial-runtime" class="level3">
<h3 class="anchored" data-anchor-id="polynomial-runtime">Polynomial runtime</h3>
<ul>
<li>Any algorithm of <span class="math inline">\(n\)</span> raised to a power of <span class="math inline">\(k\)</span></li>
<li>Denoted as <span class="math inline">\(O(n^k)\)</span></li>
<li>Algorithms with an upper bound with a Big O value that is polynomial are considered efficient</li>
</ul>
<section id="binary-search" class="level4">
<h4 class="anchored" data-anchor-id="binary-search">Binary search</h4>
<ul>
<li>Denoted as <span class="math inline">\(O(log(n))\)</span> or <span class="math inline">\(O(ln n)\)</span>
<ul>
<li>natural log</li>
</ul></li>
<li>Worst case: <span class="math inline">\(log_2 n + 1\)</span></li>
<li>Versions
<ul>
<li>Iterative: returns the index of the target</li>
<li>Recursive: checks if the target exists/ was found; returns true/false</li>
</ul></li>
</ul>
<p>Doubling the input size increases the run time by 1.</p>
</section>
<section id="quadratic-time" class="level4">
<h4 class="anchored" data-anchor-id="quadratic-time">Quadratic time</h4>
<ul>
<li>Denoted as <span class="math inline">\(O(n^2)\)</span></li>
<li>Computentially expensive; small changes in n result in large increases in time</li>
</ul>
</section>
<section id="cubit-runtimes" class="level4">
<h4 class="anchored" data-anchor-id="cubit-runtimes">Cubit runtimes</h4>
<ul>
<li>Denoted as <span class="math inline">\(O(n^3)\)</span></li>
<li>Computentially expensive; small changes in n result in large increases in time</li>
</ul>
</section>
<section id="quasi-linear" class="level4">
<h4 class="anchored" data-anchor-id="quasi-linear">Quasi-linear</h4>
<ul>
<li>Denoted as <span class="math inline">\(O(n log(n))\)</span></li>
<li>Common among sorting algorithms (e.g., merge sort)</li>
</ul>
</section>
</section>
<section id="exponential-runtime" class="level3">
<h3 class="anchored" data-anchor-id="exponential-runtime">Exponential runtime</h3>
<ul>
<li>Denoted as <span class="math inline">\(O(k^n)\)</span> - some number raised to the n<span class="math inline">\(^{th}\)</span> power</li>
<li>As n increases slightly, runtime increases exponentially</li>
<li>These algorithms are considered inefficient</li>
<li>For example, brute force algorithms</li>
</ul>
</section>
<section id="factorial-or-combinatorial-runtimes" class="level3">
<h3 class="anchored" data-anchor-id="factorial-or-combinatorial-runtimes">Factorial or combinatorial runtimes</h3>
<ul>
<li>Denoted as <span class="math inline">\(O(n!)\)</span></li>
<li>E.g., traveling sales person problem</li>
</ul>
<div style="page-break-after: always;"></div>
</section>
</section>
</section>
<section id="calculating-worst-case-complexity" class="level1">
<h1>Calculating [worst case] complexity</h1>
<p>When calculating runtime (i.e., time complexity), the upper bound is equal to the least efficient step in the algorithm.</p>
<div style="page-break-after: always;"></div>
</section>
<section id="recursion-and-space-complexity" class="level1">
<h1>Recursion and space complexity</h1>
<p>Def: Recursion - self-reference Def: Recursive function - a function that calls itself Def: Space complexity</p>
<ul>
<li>A measure of how much working storage or extra storage is needed as an algorithm grows</li>
<li>Measures what additional storage is needed as the algo runs while finding a solution</li>
</ul>
<p>Def: Tail recursion - when the recursive function call is the last line [of code] of the function</p>
<p>Conventions of a recursive function:</p>
<ul>
<li>Requires a stopping condition</li>
<li>Typically start the body of the recursive function with the stopping criteria</li>
<li>The stopping condition is commonly called the base case</li>
</ul>
<p>Iterative solutions imply a loop structure (e.g., while or for loops)</p>
<p>Functional languages tend to prefer recursion because they try to avoid changing data given to a function.</p>
<p>Python doesnâ€™t like recursion and has max recursion depth.</p>
<p>Space complexity is also measured using worst case scenarios with Big O notation.</p>
<section id="binary-search-1" class="level2">
<h2 class="anchored" data-anchor-id="binary-search-1">Binary search</h2>
<p>Iterative BS has <span class="math inline">\(O(1)\)</span> space complexity or constant time because no new lists are created. Only the indeces (first, last in our ./code/binary-search.py file) are updated.</p>
<p>In recursive BS new lists are created during each run. The recursive version of BS has space complexity <span class="math inline">\(O(log(n)))\)</span>.</p>
<p>Advanced topic: tail optimization Advanced topic: tail call optimization / elimination</p>
<p>Knowing how the [programming] language youâ€™re working with handles recursion will help guide whether to choose an iterative or recursive solution. For example, python does not implement tail optimization. Thus, while both the iterative and the recursive versions of BS have <span class="math inline">\(O(log(n))\)</span> time complexity, the recursive version has a bigger space complexity (<span class="math inline">\(O(log(n))\)</span>). In Python, we would prefer the iterative solution.</p>
<div style="page-break-after: always;"></div>
</section>
</section>
<section id="search-algos" class="level1">
<h1>Search algos</h1>
<p>Where the value lies in the range matters more than the specific value</p>
<p>Algorithms:</p>
<ul>
<li>Linear/ sequential/ simple search
<ul>
<li>input: list of values</li>
</ul></li>
<li>Binary search:
<ul>
<li>input: <strong>sorted</strong> list of values</li>
<li>output: index of target value or NULL (i.e., not found or does not exist)</li>
</ul></li>
</ul>
<div style="page-break-after: always;"></div>
</section>
<section id="sorting-algos" class="level1">
<h1>Sorting algos</h1>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Santiago Rodriguez</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with Quarto</p>
</div>
  </div>
</footer>




</body></html>